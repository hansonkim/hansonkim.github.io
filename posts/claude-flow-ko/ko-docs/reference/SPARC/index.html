<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SPARC</title>
  <link rel="stylesheet" href="/css/style.css">
</head>
<body>
  <header>
    <nav>
      <a href="/" class="logo">Hanson Kim</a>
      <ul>
        <li><a href="/">Home</a></li>
        <li><a href="/blog/">Blog</a></li>
      </ul>
    </nav>
  </header>

  <main>
    
<article class="post">
  <header class="post-header">
    <h1>SPARC</h1>
    <time datetime="2025년 10월 15일">2025년 10월 15일</time>
    
    <div class="tags">
      
        
      
        
        <span class="tag">Claude-Flow</span>
        
      
        
        <span class="tag">문서</span>
        
      
        
        <span class="tag">AI</span>
        
      
    </div>
    
  </header>

  <div class="post-content">
    <h1>SPARC 방법론 문서</h1>
<h2>개요</h2>
<p>SPARC (Specification → Pseudocode → Architecture → Refinement → Code)는 다양한 소프트웨어 개발 작업을 위한 구조화된 모드 기반 개발 환경을 제공하는 체계적인 개발 방법론입니다. 이 종합적인 접근 방식은 모든 개발 단계에서 일관되고 고품질의 결과를 보장합니다.</p>
<h3>핵심 철학</h3>
<p>SPARC는 개발을 임시적인 코딩에서 체계적인 엔지니어링으로 전환합니다:</p>
<ol>
<li><strong>Specification 우선</strong>: 구축하기 전에 무엇을 구축해야 하는지 정의</li>
<li><strong>Pseudocode 계획</strong>: 구현 전에 로직 사고</li>
<li><strong>Architecture 설계</strong>: 시스템 구조 및 관계 계획</li>
<li><strong>Refinement 프로세스</strong>: 설계 및 구현의 반복적 개선</li>
<li><strong>Code 구현</strong>: 명확한 방향 및 검증된 접근 방식으로 실행</li>
</ol>
<h3>주요 이점</h3>
<ul>
<li><strong>체계적 접근</strong>: 구조화된 방법론을 통한 오류 감소</li>
<li><strong>모드 특화</strong>: 각 개발 작업에 최적화된 실행 환경</li>
<li><strong>메모리 통합</strong>: 개발 세션 간 지속적인 컨텍스트</li>
<li><strong>병렬 실행</strong>: BatchTool을 사용한 여러 모드의 동시 작업</li>
<li><strong>품질 보증</strong>: 내장된 모범 사례 및 검증 단계</li>
</ul>
<h2>SPARC 모드 참조</h2>
<h3>핵심 개발 모드</h3>
<h4>1. <strong>orchestrator</strong> - 다중 Agent 작업 오케스트레이션</h4>
<ul>
<li><strong>목적</strong>: 여러 agent 간 복잡한 개발 작업 조정</li>
<li><strong>적합 대상</strong>: 여러 전문가가 필요한 대규모 프로젝트</li>
<li><strong>도구</strong>: TodoWrite, TodoRead, Task, Memory, Bash</li>
<li><strong>사용 패턴</strong>: 분산 실행을 통한 중앙 조정</li>
<li><strong>모범 사례</strong>:
<ul>
<li>여러 파일 작업에 batch 작업 사용</li>
<li>팀 조정을 위해 Memory에 중간 결과 저장</li>
<li>독립적인 작업에 병렬 실행 활성화</li>
<li>집약적인 작업 중 리소스 사용량 모니터링</li>
<li>팀 관리를 위한 중앙 집중식 조정 활용</li>
</ul>
</li>
</ul>
<h4>2. <strong>coder</strong> - 자율 코드 생성</h4>
<ul>
<li><strong>목적</strong>: 모범 사례를 통한 구현 및 코드 생성</li>
<li><strong>적합 대상</strong>: 기능 개발, 버그 수정, 코드 리팩토링</li>
<li><strong>도구</strong>: Read, Write, Edit, MultiEdit, Bash, TodoWrite</li>
<li><strong>사용 패턴</strong>: 테스팅 검증을 통한 직접 구현</li>
<li><strong>모범 사례</strong>:
<ul>
<li>기존 코드 패턴 및 규칙 따르기</li>
<li>새 코드에 대한 종합 테스트 작성</li>
<li>효율성을 위해 batch 파일 작업 사용</li>
<li>적절한 오류 처리 구현</li>
<li>의미 있는 주석 및 문서 추가</li>
</ul>
</li>
</ul>
<h4>3. <strong>architect</strong> - 시스템 설계 및 Architecture</h4>
<ul>
<li><strong>목적</strong>: 고수준 시스템 설계 및 architecture 계획</li>
<li><strong>적합 대상</strong>: 시스템 architecture, 기술 결정, 디자인 패턴</li>
<li><strong>도구</strong>: Write, Memory, TodoWrite, Read</li>
<li><strong>사용 패턴</strong>: 분석 → 설계 → 문서화 → 검증</li>
<li><strong>모범 사례</strong>:
<ul>
<li>확장성 및 유지보수성을 위한 설계</li>
<li>Architecture 결정 문서화</li>
<li>명확한 구성 요소 경계 생성</li>
<li>미래 확장성 계획</li>
<li>성능 영향 고려</li>
</ul>
</li>
</ul>
<h4>4. <strong>tdd</strong> - Test-Driven Development</h4>
<ul>
<li><strong>목적</strong>: London School TDD 방법론 구현</li>
<li><strong>적합 대상</strong>: 종합 테스트 커버리지를 통한 기능 개발</li>
<li><strong>도구</strong>: Write, Edit, Bash, TodoWrite, Read</li>
<li><strong>사용 패턴</strong>: Red → Green → Refactor 사이클</li>
<li><strong>모범 사례</strong>:
<ul>
<li>구현 전에 테스트 작성</li>
<li>Red-green-refactor 사이클 따르기</li>
<li>종합 테스트 커버리지 목표</li>
<li>Edge case 및 오류 조건 테스트</li>
<li>테스트를 간단하고 집중적으로 유지</li>
</ul>
</li>
</ul>
<h3>분석 및 연구 모드</h3>
<h4>5. <strong>researcher</strong> - 심층 연구 및 분석</h4>
<ul>
<li><strong>목적</strong>: 종합 연구 및 정보 수집</li>
<li><strong>적합 대상</strong>: 기술 평가, 시장 조사, 요구사항 수집</li>
<li><strong>도구</strong>: WebSearch, WebFetch, Read, Memory, TodoWrite</li>
<li><strong>사용 패턴</strong>: 검색 → 분석 → 문서화 → 종합</li>
<li><strong>모범 사례</strong>:
<ul>
<li>여러 출처에서 정보 검증</li>
<li>나중에 참조하기 위해 Memory에 발견 사항 저장</li>
<li>구조화된 연구 보고서 작성</li>
<li>데이터 교차 참조 및 검증</li>
<li>출처 및 방법론 문서화</li>
</ul>
</li>
</ul>
<h4>6. <strong>analyst</strong> - 코드 및 데이터 분석</h4>
<ul>
<li><strong>목적</strong>: 코드베이스, 성능 및 패턴의 심층 분석</li>
<li><strong>적합 대상</strong>: 코드 리뷰, 성능 분석, 기술 부채 평가</li>
<li><strong>도구</strong>: Read, Grep, Glob, Memory, TodoWrite</li>
<li><strong>사용 패턴</strong>: 발견 → 분석 → 인사이트 → 권장사항</li>
<li><strong>모범 사례</strong>:
<ul>
<li>효율적인 검색 패턴 사용</li>
<li>코드 metrics 분석</li>
<li>패턴 및 이상 현상 식별</li>
<li>분석 결과 저장</li>
<li>실행 가능한 인사이트 생성</li>
</ul>
</li>
</ul>
<h3>품질 보증 모드</h3>
<h4>7. <strong>reviewer</strong> - 코드 리뷰 및 품질 최적화</h4>
<ul>
<li><strong>목적</strong>: 종합 코드 리뷰 및 품질 개선</li>
<li><strong>적합 대상</strong>: Pull request 리뷰, 코드 품질 감사</li>
<li><strong>도구</strong>: Read, Edit, TodoWrite, Memory</li>
<li><strong>사용 패턴</strong>: 리뷰 → 분석 → 피드백 → 검증</li>
<li><strong>모범 사례</strong>:
<ul>
<li>보안 취약점 확인</li>
<li>코드가 규칙을 따르는지 검증</li>
<li>성능 개선 제안</li>
<li>적절한 오류 처리 보장</li>
<li>테스트 커버리지 검증</li>
</ul>
</li>
</ul>
<h4>8. <strong>tester</strong> - 종합 테스팅 및 검증</h4>
<ul>
<li><strong>목적</strong>: 테스트 생성, 실행 및 검증</li>
<li><strong>적합 대상</strong>: 테스트 suite 개발, QA 검증, 회귀 테스팅</li>
<li><strong>도구</strong>: Write, Bash, Read, TodoWrite</li>
<li><strong>사용 패턴</strong>: 계획 → 구현 → 실행 → 보고</li>
<li><strong>모범 사례</strong>:
<ul>
<li>모든 코드 경로 테스트</li>
<li>Edge case 포함</li>
<li>오류 처리 검증</li>
<li>성능 특성 테스트</li>
<li>테스트 실행 자동화</li>
</ul>
</li>
</ul>
<h4>9. <strong>security-review</strong> - 보안 분석 및 강화</h4>
<ul>
<li><strong>목적</strong>: 보안 취약점 분석 및 remediation</li>
<li><strong>적합 대상</strong>: 보안 감사, 침투 테스팅, 규정 준수 검증</li>
<li><strong>도구</strong>: Read, Grep, Bash, Write, TodoWrite</li>
<li><strong>사용 패턴</strong>: 평가 → 분석 → Remediation → 검증</li>
<li><strong>모범 사례</strong>:
<ul>
<li>OWASP 가이드라인 따르기</li>
<li>일반적인 취약점 확인</li>
<li>입력 sanitization 검증</li>
<li>인증 메커니즘 리뷰</li>
<li>권한 부여 제어 테스트</li>
</ul>
</li>
</ul>
<h3>개발 지원 모드</h3>
<h4>10. <strong>debugger</strong> - 체계적 디버깅</h4>
<ul>
<li><strong>목적</strong>: 체계적 접근 방식으로 문제 디버그 및 수정</li>
<li><strong>적합 대상</strong>: 버그 조사, 오류 해결, 성능 문제</li>
<li><strong>도구</strong>: Read, Edit, Bash, TodoWrite</li>
<li><strong>사용 패턴</strong>: 재현 → 분석 → 해결 → 검증</li>
<li><strong>모범 사례</strong>:
<ul>
<li>문제를 일관되게 재현</li>
<li>체계적 디버깅 접근 방식 사용</li>
<li>진단 로깅 추가</li>
<li>증상이 아닌 근본 원인 수정</li>
<li>회귀 방지 테스트 작성</li>
</ul>
</li>
</ul>
<h4>11. <strong>optimizer</strong> - 성능 최적화</h4>
<ul>
<li><strong>목적</strong>: 성능 분석 및 최적화</li>
<li><strong>적합 대상</strong>: 성능 병목 현상, 리소스 최적화, 확장성</li>
<li><strong>도구</strong>: Read, Edit, Bash, Memory, TodoWrite</li>
<li><strong>사용 패턴</strong>: 프로파일링 → 분석 → 최적화 → 검증</li>
<li><strong>모범 사례</strong>:
<ul>
<li>최적화 전 프로파일링</li>
<li>병목 현상에 집중</li>
<li>개선 사항 측정</li>
<li>가독성과 성능 균형</li>
<li>최적화 근거 문서화</li>
</ul>
</li>
</ul>
<h4>12. <strong>documenter</strong> - 문서 생성</h4>
<ul>
<li><strong>목적</strong>: 기술 문서 작성 및 유지보수</li>
<li><strong>적합 대상</strong>: API 문서, 사용자 가이드, 기술 사양</li>
<li><strong>도구</strong>: Write, Read, TodoWrite</li>
<li><strong>사용 패턴</strong>: 분석 → 구조 → 내용 → 리뷰</li>
<li><strong>모범 사례</strong>:
<ul>
<li>문서를 최신 상태로 유지</li>
<li>예제 포함</li>
<li>API를 철저하게 문서화</li>
<li>명확한 언어 사용</li>
<li>논리적으로 구성</li>
</ul>
</li>
</ul>
<h3>특화 모드</h3>
<h4>13. <strong>devops</strong> - DevOps 및 Infrastructure</h4>
<ul>
<li><strong>목적</strong>: Infrastructure, CI/CD, 배포 자동화</li>
<li><strong>적합 대상</strong>: Pipeline 설정, 컨테이너화, Infrastructure as Code</li>
<li><strong>도구</strong>: Write, Bash, Read, TodoWrite</li>
<li><strong>사용 패턴</strong>: 계획 → 구성 → 자동화 → 모니터링</li>
<li><strong>모범 사례</strong>:
<ul>
<li>반복 작업 자동화</li>
<li>Infrastructure as Code 사용</li>
<li>적절한 모니터링 구현</li>
<li>보안 모범 사례 보장</li>
<li>배포 절차 문서화</li>
</ul>
</li>
</ul>
<h4>14. <strong>integration</strong> - 시스템 통합</h4>
<ul>
<li><strong>목적</strong>: API 통합, 서비스 통신, 데이터 흐름</li>
<li><strong>적합 대상</strong>: Third-party 통합, microservices 통신</li>
<li><strong>도구</strong>: Read, Write, Bash, WebFetch, TodoWrite</li>
<li><strong>사용 패턴</strong>: 분석 → 설계 → 구현 → 테스팅</li>
<li><strong>모범 사례</strong>:
<ul>
<li>통합 실패를 우아하게 처리</li>
<li>적절한 재시도 메커니즘 구현</li>
<li>통합 상태 모니터링</li>
<li>API contract 문서화</li>
<li>통합 시나리오 테스트</li>
</ul>
</li>
</ul>
<h4>15. <strong>mcp</strong> - MCP Tool 개발</h4>
<ul>
<li><strong>목적</strong>: Model Context Protocol tool 개발 및 통합</li>
<li><strong>적합 대상</strong>: Claude 통합, tool 개발, protocol 구현</li>
<li><strong>도구</strong>: Write, Read, Bash, TodoWrite</li>
<li><strong>사용 패턴</strong>: Specification → 구현 → 테스팅 → 통합</li>
<li><strong>모범 사례</strong>:
<ul>
<li>MCP specification 따르기</li>
<li>적절한 오류 처리 구현</li>
<li>Tool 상호작용 테스트</li>
<li>Tool 기능 문서화</li>
<li>Protocol 준수 검증</li>
</ul>
</li>
</ul>
<h4>16. <strong>ask</strong> - 요구사항 분석</h4>
<ul>
<li><strong>목적</strong>: 요구사항 수집 및 명확화</li>
<li><strong>적합 대상</strong>: 프로젝트 범위 지정, 이해관계자 커뮤니케이션, 요구사항 검증</li>
<li><strong>도구</strong>: WebSearch, Memory, TodoWrite, Read</li>
<li><strong>사용 패턴</strong>: 발견 → 분석 → 명확화 → 문서화</li>
<li><strong>모범 사례</strong>:
<ul>
<li>명확화 질문하기</li>
<li>가정 문서화</li>
<li>이해 검증</li>
<li>Edge case 식별</li>
<li>요구사항 우선순위 지정</li>
</ul>
</li>
</ul>
<h4>17. <strong>tutorial</strong> - 교육 콘텐츠 작성</h4>
<ul>
<li><strong>목적</strong>: Tutorial 및 학습 콘텐츠 개발</li>
<li><strong>적합 대상</strong>: 문서, 교육 자료, 교육 리소스</li>
<li><strong>도구</strong>: Write, Read, TodoWrite, WebSearch</li>
<li><strong>사용 패턴</strong>: 계획 → 내용 → 예제 → 리뷰</li>
<li><strong>모범 사례</strong>:
<ul>
<li>내용을 논리적으로 구조화</li>
<li>실용적인 예제 포함</li>
<li>모든 코드 예제 테스트</li>
<li>다양한 기술 수준 고려</li>
<li>명확한 다음 단계 제공</li>
</ul>
</li>
</ul>
<h2>명령어 구문 및 옵션</h2>
<h3>기본 명령어</h3>
<pre><code class="language-bash"># 사용 가능한 모든 SPARC 모드 목록
npx claude-flow@alpha sparc modes [--verbose]

# 특정 모드에 대한 상세 정보 가져오기
npx claude-flow@alpha sparc info &lt;mode-slug&gt;

# 특정 SPARC 모드에서 작업 실행
npx claude-flow@alpha sparc run &lt;mode&gt; &quot;&lt;task-description&gt;&quot;

# Test-Driven Development workflow 실행
npx claude-flow@alpha sparc tdd &quot;&lt;feature-description&gt;&quot;
</code></pre>
<h3>명령어 옵션</h3>
<h4>전역 Flag</h4>
<ul>
<li><code>--help, -h</code> - 도움말 정보 표시</li>
<li><code>--verbose, -v</code> - 상세 출력 활성화</li>
<li><code>--dry-run, -d</code> - 실행 없이 구성 표시</li>
<li><code>--non-interactive, -n</code> - 사용자 프롬프트 없이 실행</li>
<li><code>--namespace &lt;name&gt;</code> - 사용자 정의 메모리 namespace 사용</li>
</ul>
<h4>권한 제어</h4>
<ul>
<li><code>--enable-permissions</code> - 권한 프롬프트 활성화 (기본값: auto-skip)</li>
<li><code>--dangerously-skip-permissions</code> - 모든 권한 프롬프트 건너뛰기 (자동 적용)</li>
</ul>
<h4>구성</h4>
<ul>
<li><code>--config &lt;path&gt;</code> - 사용자 정의 MCP 구성 파일 사용</li>
<li><code>--interactive, -i</code> - Interactive 모드 활성화 (TDD workflow용)</li>
</ul>
<h3>고급 사용 예제</h3>
<h4>단일 모드 실행</h4>
<pre><code class="language-bash"># 사용자 정의 namespace로 코드 구현
npx claude-flow@alpha sparc run code &quot;implement user authentication&quot; --namespace auth_system

# Verbose 출력으로 architecture 계획
npx claude-flow@alpha sparc run architect &quot;design microservices architecture&quot; --verbose

# 결제 시스템을 위한 test-driven development
npx claude-flow@alpha sparc run tdd &quot;payment processing with validation&quot; --namespace payments

# 기존 코드베이스의 보안 리뷰
npx claude-flow@alpha sparc run security-review &quot;audit authentication system&quot; --verbose

# Non-interactive 모드로 성능 최적화
npx claude-flow@alpha sparc run optimizer &quot;optimize database queries&quot; --non-interactive
</code></pre>
<h4>TDD Workflow</h4>
<pre><code class="language-bash"># Interactive TDD workflow (단계별)
npx claude-flow@alpha sparc tdd &quot;user registration system&quot; --interactive

# 자동화된 TDD workflow
npx claude-flow@alpha sparc tdd &quot;shopping cart functionality&quot; --namespace ecommerce

# 사용자 정의 구성으로 TDD
npx claude-flow@alpha sparc tdd &quot;payment gateway integration&quot; --config ./custom-mcp.json
</code></pre>
<h2>Pipeline 및 Batch 실행</h2>
<h3>BatchTool 통합</h3>
<p>SPARC 모드는 병렬 및 순차 실행을 위해 BatchTool을 사용하여 오케스트레이션할 수 있습니다:</p>
<h4>병렬 실행</h4>
<pre><code class="language-bash"># 여러 모드를 동시에 실행
batchtool run --parallel \
  &quot;npx claude-flow@alpha sparc run architect 'system design' --non-interactive&quot; \
  &quot;npx claude-flow@alpha sparc run security-review 'security requirements' --non-interactive&quot; \
  &quot;npx claude-flow@alpha sparc run researcher 'technology evaluation' --non-interactive&quot;
</code></pre>
<h4>순차 Pipeline</h4>
<pre><code class="language-bash"># 결과 chaining을 통한 순차 실행
batchtool pipeline \
  --stage1 &quot;npx claude-flow@alpha sparc run ask 'gather requirements' --non-interactive&quot; \
  --stage2 &quot;npx claude-flow@alpha sparc run architect 'design system' --non-interactive&quot; \
  --stage3 &quot;npx claude-flow@alpha sparc run code 'implement features' --non-interactive&quot; \
  --stage4 &quot;npx claude-flow@alpha sparc run tdd 'create test suite' --non-interactive&quot;
</code></pre>
<h4>Boomerang 패턴</h4>
<pre><code class="language-bash"># 피드백 루프를 통한 반복적 개발
batchtool orchestrate --boomerang \
  --research &quot;npx claude-flow@alpha sparc run researcher 'best practices' --non-interactive&quot; \
  --design &quot;npx claude-flow@alpha sparc run architect 'system design' --non-interactive&quot; \
  --implement &quot;npx claude-flow@alpha sparc run code 'feature implementation' --non-interactive&quot; \
  --test &quot;npx claude-flow@alpha sparc run tdd 'validation suite' --non-interactive&quot; \
  --refine &quot;npx claude-flow@alpha sparc run optimizer 'performance tuning' --non-interactive&quot;
</code></pre>
<h3>전체 개발 Pipeline</h3>
<h4>완전한 기능 개발</h4>
<pre><code class="language-bash"># End-to-end 기능 개발 pipeline
npx claude-flow@alpha sparc pipeline &quot;user authentication system&quot; \
  --phases &quot;ask,architect,security-review,code,tdd,optimizer,documenter&quot; \
  --namespace &quot;auth_feature&quot; \
  --parallel-compatible &quot;ask,security-review,documenter&quot;
</code></pre>
<h4>Microservices 개발</h4>
<pre><code class="language-bash"># 병렬 microservices 개발
batchtool run --max-parallel 3 \
  &quot;npx claude-flow@alpha sparc run code 'user service' --namespace users --non-interactive&quot; \
  &quot;npx claude-flow@alpha sparc run code 'order service' --namespace orders --non-interactive&quot; \
  &quot;npx claude-flow@alpha sparc run code 'payment service' --namespace payments --non-interactive&quot; \
  &quot;npx claude-flow@alpha sparc run integration 'service communication' --namespace integration --non-interactive&quot;
</code></pre>
<h2>TDD Workflow 통합</h2>
<h3>London School TDD 방법론</h3>
<p>SPARC TDD 모드는 다음 단계로 London School TDD를 구현합니다:</p>
<h4>1. 테스트 계획 및 분석 (10분)</h4>
<ul>
<li>요구사항 및 기존 architecture 분석</li>
<li>테스트 경계 및 acceptance criteria 정의</li>
<li>테스트 구조 계획 (unit, integration, e2e)</li>
<li>필요한 test double 식별 (mock, stub, spy)</li>
</ul>
<h4>2. Red 단계 - 실패하는 테스트 작성 (20분)</h4>
<ul>
<li>종합 테스트 구조 생성</li>
<li>London School TDD 원칙에 따라 테스트 작성</li>
<li>Test double을 사용한 행동/계약 테스트에 집중</li>
<li>의미 있는 메시지와 함께 모든 테스트 실패 보장</li>
</ul>
<h4>3. Green 단계 - 최소 구현 (20분)</h4>
<ul>
<li>테스트를 통과하기에 충분한 코드만 구현</li>
<li>한 번에 하나의 테스트 통과</li>
<li>모듈성 및 적절한 오류 처리 유지</li>
<li>진행하면서 커버리지 추적</li>
</ul>
<h4>4. Refactor 단계 - 최적화 및 정리 (15분)</h4>
<ul>
<li>테스트를 green 상태로 유지하면서 리팩토링</li>
<li>공통 패턴 추출 및 명확성 개선</li>
<li>알고리즘 최적화 및 중복 감소</li>
<li>테스트 유지보수성 개선</li>
</ul>
<h4>5. 문서화 및 검증 (10분)</h4>
<ul>
<li>커버리지 보고서 생성</li>
<li>테스트 시나리오 및 실행 가이드 문서화</li>
<li>CI/CD 테스트 구성 설정</li>
<li>Acceptance criteria에 대해 검증</li>
</ul>
<h3>TDD 명령어 예제</h3>
<pre><code class="language-bash"># Interactive TDD workflow 시작
npx claude-flow@alpha sparc tdd &quot;shopping cart with discounts&quot; --interactive

# 사용자 정의 namespace로 자동화된 TDD
npx claude-flow@alpha sparc tdd &quot;payment validation system&quot; --namespace payments

# Integration testing에 집중한 TDD
npx claude-flow@alpha sparc run tdd &quot;API endpoint with database&quot; --namespace api_tests
</code></pre>
<h2>Memory Namespace 사용</h2>
<h3>Namespace 전략</h3>
<p>Memory namespace는 컨텍스트를 구성하고 모드 간 조정을 가능하게 합니다:</p>
<h4>Namespace 패턴</h4>
<ul>
<li><code>feature_&lt;name&gt;</code> - 기능 개발 컨텍스트</li>
<li><code>bug_&lt;id&gt;</code> - 버그 수정 추적</li>
<li><code>arch_&lt;system&gt;</code> - Architecture 계획</li>
<li><code>test_&lt;suite&gt;</code> - 테스트 개발</li>
<li><code>integration_&lt;service&gt;</code> - 통합 작업</li>
</ul>
<h4>Memory 작업</h4>
<pre><code class="language-bash"># 진행 상황 및 컨텍스트 저장
npx claude-flow@alpha memory store &lt;namespace&gt;_progress &quot;Current implementation status&quot;
npx claude-flow@alpha memory store &lt;namespace&gt;_decisions &quot;Key architectural decisions&quot;
npx claude-flow@alpha memory store &lt;namespace&gt;_blockers &quot;Current impediments&quot;

# 이전 작업 및 컨텍스트 쿼리
npx claude-flow@alpha memory query &lt;namespace&gt;
npx claude-flow@alpha memory query &lt;namespace&gt;_architecture
npx claude-flow@alpha memory query &lt;namespace&gt;_requirements

# 모든 namespace 목록
npx claude-flow@alpha memory list
</code></pre>
<h3>크로스 모드 조정</h3>
<h4>공유 컨텍스트 예제</h4>
<pre><code class="language-bash"># Architect가 시스템 설계 저장
npx claude-flow@alpha sparc run architect &quot;design user system&quot; --namespace user_feature

# Coder가 architect의 설계를 기반으로 구현
npx claude-flow@alpha sparc run code &quot;implement user CRUD&quot; --namespace user_feature

# Tester가 구현 검증
npx claude-flow@alpha sparc run tdd &quot;test user operations&quot; --namespace user_feature

# 모든 모드가 컨텍스트를 위해 user_feature namespace 공유
</code></pre>
<h2>실용적 예제</h2>
<h3>웹 Application 개발</h3>
<h4>Full-Stack 개발 Pipeline</h4>
<pre><code class="language-bash"># 1. 요구사항 및 연구
npx claude-flow@alpha sparc run ask &quot;e-commerce requirements&quot; --namespace ecommerce

# 2. 시스템 architecture
npx claude-flow@alpha sparc run architect &quot;microservices design&quot; --namespace ecommerce

# 3. 병렬 서비스 개발
batchtool run --parallel \
  &quot;npx claude-flow@alpha sparc run code 'user service API' --namespace ecommerce_users --non-interactive&quot; \
  &quot;npx claude-flow@alpha sparc run code 'product catalog API' --namespace ecommerce_products --non-interactive&quot; \
  &quot;npx claude-flow@alpha sparc run code 'order processing API' --namespace ecommerce_orders --non-interactive&quot;

# 4. 통합 및 테스팅
npx claude-flow@alpha sparc run integration &quot;service communication&quot; --namespace ecommerce
npx claude-flow@alpha sparc run tdd &quot;end-to-end testing&quot; --namespace ecommerce

# 5. 보안 및 최적화
batchtool run --parallel \
  &quot;npx claude-flow@alpha sparc run security-review 'security audit' --namespace ecommerce --non-interactive&quot; \
  &quot;npx claude-flow@alpha sparc run optimizer 'performance tuning' --namespace ecommerce --non-interactive&quot;
</code></pre>
<h3>API 개발</h3>
<h4>TDD를 사용한 RESTful API</h4>
<pre><code class="language-bash"># Test-driven API 개발
npx claude-flow@alpha sparc tdd &quot;RESTful user management API&quot; --namespace user_api

# 인증 layer 추가
npx claude-flow@alpha sparc run security-review &quot;API authentication&quot; --namespace user_api

# 성능 최적화
npx claude-flow@alpha sparc run optimizer &quot;API response times&quot; --namespace user_api

# 문서 생성
npx claude-flow@alpha sparc run documenter &quot;API documentation&quot; --namespace user_api
</code></pre>
<h3>버그 수정 Workflow</h3>
<h4>체계적 버그 해결</h4>
<pre><code class="language-bash"># 1. 연구 및 재현
npx claude-flow@alpha sparc run debugger &quot;investigate login failures&quot; --namespace bug_1234

# 2. 근본 원인 분석
npx claude-flow@alpha sparc run analyst &quot;analyze authentication flow&quot; --namespace bug_1234

# 3. 테스트로 수정 구현
npx claude-flow@alpha sparc run tdd &quot;fix and test authentication&quot; --namespace bug_1234

# 4. 보안 검증
npx claude-flow@alpha sparc run security-review &quot;validate auth fix&quot; --namespace bug_1234
</code></pre>
<h3>DevOps 및 Infrastructure</h3>
<h4>CI/CD Pipeline 설정</h4>
<pre><code class="language-bash"># Infrastructure 계획
npx claude-flow@alpha sparc run architect &quot;CI/CD architecture&quot; --namespace devops

# Pipeline 구현
npx claude-flow@alpha sparc run devops &quot;GitHub Actions workflow&quot; --namespace devops

# 모니터링 및 alert
npx claude-flow@alpha sparc run devops &quot;application monitoring&quot; --namespace devops

# 문서화
npx claude-flow@alpha sparc run documenter &quot;deployment guide&quot; --namespace devops
</code></pre>
<h3>연구 및 분석</h3>
<h4>기술 평가</h4>
<pre><code class="language-bash"># 연구 단계
npx claude-flow@alpha sparc run researcher &quot;JavaScript framework comparison&quot; --namespace tech_eval

# Architecture 영향
npx claude-flow@alpha sparc run architect &quot;framework integration design&quot; --namespace tech_eval

# Prototype 개발
npx claude-flow@alpha sparc run code &quot;proof of concept&quot; --namespace tech_eval

# 분석 및 권장사항
npx claude-flow@alpha sparc run analyst &quot;framework recommendation&quot; --namespace tech_eval
</code></pre>
<h2>모범 사례 및 팁</h2>
<h3>개발 Workflow</h3>
<h4>1. Specification으로 시작</h4>
<ul>
<li>요구사항을 명확히 하기 위해 항상 <code>ask</code> 모드로 시작</li>
<li>가정 및 제약 조건 문서화</li>
<li>구현 전 이해 검증</li>
</ul>
<h4>2. Memory를 효과적으로 사용</h4>
<ul>
<li>의미 있는 namespace 계층 구조 생성</li>
<li>주요 결정 및 컨텍스트 저장</li>
<li>새 작업 시작 전 이전 작업 쿼리</li>
</ul>
<h4>3. 병렬 실행 활용</h4>
<ul>
<li>병렬 실행을 위한 독립적인 작업 식별</li>
<li>동시 모드 실행을 위해 BatchTool 사용</li>
<li>공유 namespace를 통한 결과 조정</li>
</ul>
<h4>4. TDD 원칙 따르기</h4>
<ul>
<li>해당되는 경우 구현 전 테스트 작성</li>
<li>높은 테스트 커버리지 유지</li>
<li>기능 개발을 위해 TDD 모드 사용</li>
</ul>
<h4>5. 성능 최적화</h4>
<ul>
<li>최적화 전 프로파일링</li>
<li>성능 개선을 위해 optimizer 모드 사용</li>
<li>가독성과 성능 균형</li>
</ul>
<h3>품질 보증</h3>
<h4>1. 보안 우선</h4>
<ul>
<li>민감한 기능에 대해 항상 security-review 실행</li>
<li>OWASP 가이드라인 따르기</li>
<li>입력 검증 및 출력 sanitization</li>
</ul>
<h4>2. 코드 품질</h4>
<ul>
<li>코드 품질 확인을 위해 reviewer 모드 사용</li>
<li>확립된 코딩 규칙 따르기</li>
<li>코드와 함께 문서 유지</li>
</ul>
<h4>3. 테스팅 전략</h4>
<ul>
<li>종합 테스팅 접근 방식 사용 (unit, integration, e2e)</li>
<li>Edge case 및 오류 조건 테스트</li>
<li>CI/CD에서 테스트 실행 자동화</li>
</ul>
<h3>협업 및 문서화</h3>
<h4>1. 크로스 모드 조정</h4>
<ul>
<li>Memory namespace를 통한 컨텍스트 공유</li>
<li>일관된 명명 규칙 사용</li>
<li>모드 간 dependency 문서화</li>
</ul>
<h4>2. 문서 유지보수</h4>
<ul>
<li>코드 변경과 함께 문서를 최신 상태로 유지</li>
<li>종합 문서를 위해 documenter 모드 사용</li>
<li>예제 및 사용 패턴 포함</li>
</ul>
<h4>3. 진행 상황 추적</h4>
<ul>
<li>Memory에 진행 상황 업데이트 저장</li>
<li>의미 있는 commit 메시지 사용</li>
<li>차단 요소 및 해결 방법 추적</li>
</ul>
<h3>일반 패턴</h3>
<h4>1. Boomerang 개발</h4>
<p>연구 → 설계 → 구현 → 테스트 → 최적화 → 루프 백</p>
<h4>2. 병렬 기능 개발</h4>
<p>조정과 함께 동시에 개발되는 여러 기능</p>
<h4>3. Pipeline 개발</h4>
<p>특화된 모드 간 hand-off를 통한 순차 단계</p>
<h4>4. 반복적 개선</h4>
<p>여러 최적화 사이클을 통한 지속적 개선</p>
<h3>성능 최적화</h3>
<h4>1. Batch 작업</h4>
<ul>
<li>가능한 경우 batch 파일 작업 사용</li>
<li>모드 간 컨텍스트 전환 최소화</li>
<li>독립적인 작업에 병렬 실행 활용</li>
</ul>
<h4>2. Memory 관리</h4>
<ul>
<li>집중된 memory namespace 사용</li>
<li>구식 컨텍스트 정리</li>
<li>공통 컨텍스트를 효율적으로 공유</li>
</ul>
<h4>3. 리소스 활용</h4>
<ul>
<li>집약적인 작업 중 리소스 사용량 모니터링</li>
<li>자동화를 위해 non-interactive 모드 사용</li>
<li>병렬성과 리소스 제약 균형</li>
</ul>
<h3>문제 해결</h3>
<h4>일반적인 문제 및 솔루션</h4>
<ol>
<li>
<p><strong>모드를 찾을 수 없음</strong></p>
<ul>
<li>프로젝트 디렉토리에 <code>.roomodes</code> 파일이 있는지 확인</li>
<li>SPARC 환경 설정을 위해 <code>npx claude-flow@alpha init --sparc</code> 실행</li>
</ul>
</li>
<li>
<p><strong>권한 문제</strong></p>
<ul>
<li>수동 제어를 위해 <code>--enable-permissions</code> 사용</li>
<li>기본 동작은 효율성을 위해 <code>--dangerously-skip-permissions</code> 사용</li>
</ul>
</li>
<li>
<p><strong>Memory Namespace 충돌</strong></p>
<ul>
<li>고유한 namespace 이름 사용</li>
<li><code>npx claude-flow@alpha memory list</code>로 기존 namespace 쿼리</li>
</ul>
</li>
<li>
<p><strong>BatchTool 통합</strong></p>
<ul>
<li>BatchTool이 설치 및 구성되었는지 확인</li>
<li>병렬 실행을 위해 <code>--non-interactive</code> flag 사용</li>
</ul>
</li>
<li>
<p><strong>성능 문제</strong></p>
<ul>
<li>디버깅을 위해 <code>--verbose</code> flag 사용</li>
<li>리소스 사용량 모니터링</li>
<li>병렬성 감소 고려</li>
</ul>
</li>
</ol>
<h3>고급 구성</h3>
<h4>사용자 정의 모드 개발</h4>
<p><code>.roomodes</code> 구성을 확장하여 사용자 정의 SPARC 모드 생성:</p>
<pre><code class="language-json">{
  &quot;customModes&quot;: [
    {
      &quot;name&quot;: &quot;Custom Mode&quot;,
      &quot;slug&quot;: &quot;custom&quot;,
      &quot;roleDefinition&quot;: &quot;Custom role description&quot;,
      &quot;customInstructions&quot;: &quot;Specific instructions&quot;,
      &quot;groups&quot;: [&quot;read&quot;, &quot;edit&quot;, &quot;command&quot;],
      &quot;source&quot;: &quot;custom&quot;
    }
  ]
}
</code></pre>
<h4>IDE와의 통합</h4>
<ul>
<li>SPARC 명령어를 인식하도록 IDE 구성</li>
<li>일반 작업을 위한 키보드 단축키 설정</li>
<li>IDE 작업 runner와 통합</li>
</ul>
<h4>CI/CD 통합</h4>
<ul>
<li>자동화된 pipeline에서 SPARC 모드 사용</li>
<li>빌드 프로세스를 위한 병렬 실행 구성</li>
<li>컨텍스트 공유를 위한 memory 지속성 통합</li>
</ul>
<hr>
<h2>요약</h2>
<p>SPARC는 임시적인 코딩을 체계적인 엔지니어링으로 전환하는 종합적인 모드 기반 개발 방법론을 제공합니다. 특화된 모드, memory 지속성 및 병렬 실행 기능을 활용하여 SPARC는 대규모로 효율적이고 고품질의 소프트웨어 개발을 가능하게 합니다.</p>
<p>주요 장점:</p>
<ul>
<li><strong>체계적 접근</strong>: 구조화된 방법론이 오류를 줄임</li>
<li><strong>모드 특화</strong>: 특정 작업에 최적화된 환경</li>
<li><strong>병렬 실행</strong>: BatchTool 통합을 통한 동시 개발</li>
<li><strong>Memory 지속성</strong>: 개발 세션 간 컨텍스트 공유</li>
<li><strong>품질 보증</strong>: 내장된 모범 사례 및 검증</li>
</ul>
<p><code>npx claude-flow@alpha sparc modes</code>로 사용 가능한 모드를 탐색하고 <code>npx claude-flow@alpha sparc run &lt;mode&gt; &quot;&lt;task&gt;&quot;</code>를 사용하여 SPARC로 체계적인 개발을 시작하세요.</p>

  </div>
</article>

  </main>

  <footer>
    <p>&copy; 2025 Hanson Kim. All rights reserved.</p>
  </footer>
</body>
</html>
