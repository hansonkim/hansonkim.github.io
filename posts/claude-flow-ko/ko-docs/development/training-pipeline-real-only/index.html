<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Training Pipeline Real Only</title>
  <link rel="stylesheet" href="/css/style.css">
</head>
<body>
  <header>
    <nav>
      <a href="/" class="logo">Hanson Kim</a>
      <ul>
        <li><a href="/">Home</a></li>
        <li><a href="/blog/">Blog</a></li>
      </ul>
    </nav>
  </header>

  <main>
    
<article class="post">
  <header class="post-header">
    <h1>Training Pipeline Real Only</h1>
    <time datetime="2025년 10월 15일">2025년 10월 15일</time>
    
    <div class="tags">
      
        
      
        
        <span class="tag">Claude-Flow</span>
        
      
        
        <span class="tag">문서</span>
        
      
        
        <span class="tag">AI</span>
        
      
    </div>
    
  </header>

  <div class="post-content">
    <h1>Training Pipeline - 실제 코드 실행만</h1>
<h2>개요</h2>
<p>Claude Flow Training Pipeline은 이제 <strong>실제 코드 실행만 독점적으로 사용</strong>합니다. 시뮬레이션 모드는 없습니다 - 모든 training이 실제 코드 파일에서 실제 npm 테스트를 실행하여 진정한 학습과 개선을 제공합니다.</p>
<h2>변경사항</h2>
<h3>이전 (v1 - 시뮬레이션 모드)</h3>
<ul>
<li><code>Math.random()</code>을 사용하여 테스트 결과 시뮬레이션</li>
<li>실제 코드 실행 없음</li>
<li>현실을 반영하지 않는 인위적인 점수</li>
<li>무작위 데이터로부터 학습</li>
</ul>
<h3>현재 (v2 - 실제 실행만)</h3>
<ul>
<li>실제 코드로 실제 JavaScript 파일 생성</li>
<li>실제 <code>npm install</code> 및 <code>npm test</code> 명령어 실행</li>
<li>실제 Jest 테스트 실행</li>
<li>진정한 테스트 결과로부터 학습</li>
<li>Agent 성능의 실제 개선 표시</li>
</ul>
<h2>작동 방식</h2>
<h3>1. 작업 생성</h3>
<p>Pipeline이 <code>.claude-flow/training/real-tasks/</code>에 <strong>실제 코드 파일</strong> 생성:</p>
<pre><code class="language-javascript">// 예제: 이메일 검증 함수
function validateEmail(email) {
  const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return regex.test(email);
}
</code></pre>
<h3>2. 전략 테스트</h3>
<p>세 가지 전략이 코드를 다르게 수정:</p>
<ul>
<li><strong>Conservative</strong>: 추가 검증 추가 (더 안정적, 느림)</li>
<li><strong>Balanced</strong>: 원본 코드 유지 (좋은 균형)</li>
<li><strong>Aggressive</strong>: 검증 감소 (빠름, 위험)</li>
</ul>
<h3>3. 실제 실행</h3>
<p>각 전략 variant는 다음을 사용하여 테스트됨:</p>
<pre><code class="language-bash">npm install  # Jest 및 dependencies 설치
npm test     # 실제 테스트 실행
npm run lint # 코드 품질 확인
</code></pre>
<h3>4. 결과로부터 학습</h3>
<p>시스템이 <strong>실제 테스트 결과</strong>로부터 학습:</p>
<ul>
<li>테스트 통과/실패율</li>
<li>실제 실행 시간</li>
<li>실제 오류 메시지</li>
<li>성능 metrics</li>
</ul>
<h2>사용법</h2>
<h3>Training 실행</h3>
<pre><code class="language-bash"># 항상 실제 코드로 실행 - 시뮬레이션 옵션 없음
./claude-flow train-pipeline run

# 옵션
./claude-flow train-pipeline run --complexity hard --iterations 5
</code></pre>
<h3>상태 확인</h3>
<pre><code class="language-bash">./claude-flow train-pipeline status

# 출력에 실제 metrics 표시:
📊 Training Pipeline Status
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

🤖 Strategy Profiles:
   conservative:
     Success Rate: 40.9%    # 실제 테스트 통과율
     Average Score: 40.25   # 실제 결과 기반
     Execution Time: 1633ms # 실제 npm test 시간
     Real Executions: 4     # 실제 실행 수
</code></pre>
<h3>성능 검증</h3>
<pre><code class="language-bash">./claude-flow train-pipeline validate

# 현재 실제 성능 표시:
📊 Current Performance:
   Success Rate: 43.1%      # 실제 성공률
   Avg Execution Time: 1567ms # 실제 실행 시간
   Average Score: 41.05      # 실제 테스트 기반
</code></pre>
<h2>실제 결과 예제</h2>
<p>실제 training 실행에서:</p>
<h3>초기 상태 (반복 1)</h3>
<pre><code>📊 Learning Results:
   conservative: Score 12.64, Success 0.0%, Time 1839ms
   balanced: Score 12.98, Success 0.0%, Time 1756ms
   aggressive: Score 13.24, Success 0.0%, Time 1691ms
</code></pre>
<h3>수정 후 (반복 2)</h3>
<pre><code>📊 Learning Results:
   conservative: Score 42.56, Success 50.0%, Time 1860ms
   balanced: Score 42.57, Success 50.0%, Time 1858ms
   aggressive: Score 43.33, Success 50.0%, Time 1667ms

📈 Improvements:
   Success Rate: +14.3%
   Execution Time: -10.8%
   Score: +3.0%
</code></pre>
<h2>작업 복잡도 수준</h2>
<h3>Easy</h3>
<ul>
<li>간단한 함수 (이메일 검증, 문자열 조작)</li>
<li>명확한 pass/fail이 있는 기본 테스트</li>
<li>빠른 실행 (~2초)</li>
</ul>
<h3>Medium</h3>
<ul>
<li>Express를 사용한 API endpoint</li>
<li>Integration 테스트</li>
<li>중간 실행 (~3-4초)</li>
</ul>
<h3>Hard</h3>
<ul>
<li>복잡한 알고리즘 (정렬, 검색)</li>
<li>성능 중요 코드</li>
<li>종합 테스트 suite (~5초 이상)</li>
</ul>
<h2>생성된 파일</h2>
<p>Training pipeline이 실제 프로젝트 구조 생성:</p>
<pre><code>.claude-flow/training/real-tasks/
└── task-[timestamp]/
    └── [taskName]/
        ├── index.js        # 실제 구현
        ├── index.test.js   # 실제 Jest 테스트
        └── package.json    # 실제 dependencies
</code></pre>
<h2>학습 메커니즘</h2>
<h3>Exponential Moving Average</h3>
<pre><code class="language-javascript">// 학습률: 실제 실행의 경우 0.4 (시뮬레이션보다 높음)
newReliability = oldReliability * 0.6 + newScore * 0.4
</code></pre>
<h3>추적되는 실제 Metrics</h3>
<ul>
<li><strong>Success Rate</strong>: 실제 테스트 통과 백분율</li>
<li><strong>Execution Time</strong>: 실제 npm test 지속 시간</li>
<li><strong>Score</strong>: 성공과 속도의 가중 조합</li>
<li><strong>Trend</strong>: 시간 경과에 따른 개선 또는 하락</li>
</ul>
<h2>실제 실행의 이점</h2>
<ol>
<li><strong>진정한 학습</strong>: Agent가 실제 테스트 결과로부터 학습</li>
<li><strong>실제 성능</strong>: Metrics가 실제 실행 시간 반영</li>
<li><strong>정확한 예측</strong>: 실제 데이터 기반의 미래 예측</li>
<li><strong>실용적인 개선</strong>: 실제로 작동하는 최적화</li>
<li><strong>인위적인 편향 없음</strong>: 결과에 영향을 미치는 난수 없음</li>
</ol>
<h2>시뮬레이션에서 마이그레이션</h2>
<p>시뮬레이션 모드에서 기존 프로필이 있는 경우:</p>
<ol>
<li>시스템이 계속 사용하지만 실제 데이터로 업데이트</li>
<li>몇 번의 실제 실행 후, 데이터가 완전히 현실 기반이 됨</li>
<li>이전 시뮬레이션 점수가 실제 점수로 덮어써짐</li>
</ol>
<h2>문제 해결</h2>
<h3>테스트 실패</h3>
<ul>
<li>Jest가 설치되었는지 확인: <code>npm ls jest</code></li>
<li>테스트 구문이 올바른지 검증</li>
<li>Template에서 적절한 regex escaping 확인</li>
</ul>
<h3>느린 실행</h3>
<ul>
<li>첫 실행의 경우 정상 (npm install)</li>
<li>후속 실행은 더 빠름 (캐시된 dependencies)</li>
<li>더 빠른 반복을 위해 <code>--complexity easy</code> 사용</li>
</ul>
<h3>개선 없음</h3>
<ul>
<li>실제 개선에는 여러 반복 필요</li>
<li>테스트 실행의 일부 무작위성은 정상</li>
<li>단일 실행보다 추세에 집중</li>
</ul>
<h2>요약</h2>
<p>Training Pipeline은 이제 <strong>실제 코드 실행</strong>을 기반으로 <strong>실제 machine learning</strong>을 제공합니다. 더 이상 시뮬레이션 없음 - 모든 점수, 모든 metric, 모든 개선은 실제 npm 테스트 결과를 기반으로 합니다. 이는 agent 개선이 실제 성능 향상으로 직접 전환되도록 보장합니다.</p>

  </div>
</article>

  </main>

  <footer>
    <p>&copy; 2025 Hanson Kim. All rights reserved.</p>
  </footer>
</body>
</html>
